<h1>
  Object Basics
</h1>

<p>
  Graffiti is essentially a shared database of JSON objects.
  You can put objects into the database that can represent things posts, likes, or profile information.
  Then you or other people can query the database for objects that are relevant to you.
</p>

<p>
  Graffiti is not any old database, it has certain properties that allow you to limit <em>who</em> can see your data and <em>where</em> they can see it.
  We'll get to that in the next sections on <RouterLink to="privacy">privacy</RouterLink> and <RouterLink to="context">context</RouterLink>
  but for now we're just going to introduce the basics of creating, viewing, and modifying data.
</p>

<p>
  To add data to the database you simply need to pass the JSON object you want to add to the global <code class="language-js">$graffitiUpdate</code> function.
  In the example below, clicking the button creates an object with <code class="language-js">type</code> "Boop".
</p>

<GraffitiPlayground path="booper" />

<p>
  Did you click the button and nothing happened? Well, we also need a way to <em>view</em> objects in the Graffiti database.
</p>

<p>
  To see objects that you or others have created you can use 
  <code class="language-js">GraffitiObjects</code>,
  a <a href="https://vuejs.org/guide/components/slots.html#renderless-components">renderless Vue component</a>.
  The component uses a <a href="https://vuejs.org/guide/components/slots.html#scoped-slots">scoped slot</a> to expose the variable <code class="language-js">objects</code>, which is an array
  of all the JSON objects matching certain filters.
</p>

<p>
  Below, we're mapping the <code class="language-js">objects</code> variable exposed by the <code class="language-js">GraffitiObjects</code> component to the variable <code class="language-js">boops</code> &mdash; remapping the variable helps with readability and it prevents name collisions if you are using nested <code class="language-js">GraffitiObjects</code> components.
  Then, we're filtering for objects that <em>you</em> have created and we use <a href="https://json-schema.org/">JSON schema</a> notation to filter for objects of type "Boop".
</p>

<GraffitiPlayground path="boop-viewer" />

<p>
  Note making a boop in the top component is immediately reflected in the bottom component. In fact, the change is reflected immediately on other devices and for other users which makes it possible to use Graffiti for things like instant messaging and collaborative editing.
</p>

<h2>
  Mutation
</h2>

<p>
  You can modify or delete any object you put into the Graffiti database.
  To modify a Graffiti object, all you need to do is modify it locally and that change will be synced with the server and other users. In the example below we create a button that turns Boops into Bops, just by directly modifying an object's <code class="language-js">.type</code> property.
</p>

<p>
  You can delete objects by calling <code class="language-js">delete</code> on an object's <code class="language-js">id</code> property, as also demonstrated in the example below.
  <code class="language-js">id</code> is a unique URI assigned to every object that we'll describe along with other special regulated properties at the end of this section.
</p>

<p>
  Note that you <em>cannot</em> change or delete other people's objects.
  In later sections we describe how you can implement things like <RouterLink to="/moderation">moderation</RouterLink> and <RouterLink to="ordered-lists">ordered lists</RouterLink> under these restrictions.
</p>

<GraffitiPlayground path="boopbop" />

Alternatively you can call the <code class="language-js">removeMine</code> function on an <code class="language-js">objects</code> array to remove all objects from that array that you created.
This is useful for clearing "reaction" objects such as "likes" or the "Wave" objects used in the <RouterLink to="/">introduction</RouterLink> demo.

<GraffitiPlayground path="remove-mine" />

<h2>
  Filtering
</h2>

<p>
  As we saw in the last demo, you can filter objects using the keyword <code class="language-js">mine</code> and by passing in a JSON schema <code class="language-js">schema</code>.
  Alternatively, you can also pass in a <code class="language-js">filter</code> function, or a <code class="language-js">sort</code> function which are equivalent to the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter">prototypical Array functions</a>. For example:

  <GraffitiPlayground path="boop-viewer-filter" />
</p>

<p>
  Using <code class="language-js">filter</code> is more concise in this case, but it is less human-readable.
  We recommend using <code class="language-js">schema</code> as much as possible unless there is something that requires special programmatic filtering that is outside the scope of JSON schema.
</p>

<p>
  Another common key word is <code class="language-js">sortBy</code>
</p>

<h2>
  Default Filtering
</h2>

<p>
  Graffiti objects are very flexible but there are certain properties that are enforced either because they have special server-side meanings or because they are convention.
</p>

<p>
  The following are special server-regulated fields:
</p>

<ul>
  <li>
    <code class="language-js">id</code>
    is a unique identifier associated with each object.
    As described above, deleting this required property deletes the whole object.
    We also show how this can be used to "point" to objects in the <RouterLink to="/context">context section</RouterLink>.
  </li>
  <li>
    <code class="language-js">context</code>
    is a list of unique identifiers that specify "where" an object can be found.
    We explore this property in the <RouterLink to="tags">context section</RouterLink>.
  </li>
  <li>
    <code class="language-js">actor</code>
    is a unique identified associated with each user and also attached to each object.
    We explore how this can be used to associate data with a user in the context section and how it is related to private messaging in the privacy section.
  </li>
  <li>
    <code class="language-js">published</code>
    and
    <code class="language-js">updated</code>
    are required timestamps that specify when an object was created and when it was last updated.
    These do not necessarily need to be accurate.
  </li>
  <li>
    <code class="language-js">bto</code>
    and
    <code class="language-js">bcc</code>
    optionally specify "who" is allowed to see an object,
    if that object is private.
    We'll also explore these properties in the <RouterLink to="privacy">privacy section</RouterLink>.
  </li>
</ul>

<p>
<code class="language-js">id</code>, <code class="actor">actor</code>, <code class="language-js">published</code>, and <code class="language-js">updated</code>  are assigned automatically when you call <code class="language-js">$graffitiUpdate</code>. <code class="language-js">context</code> is also given a default as specified in the <RouterLink to="/context">context</RouterLink> section although this can be overridden.
  <code class="language-js">bto</code> and <code class="language-js">bcc</code> must be assigned manually and make an obejct private if they exist.
</p>

<p>
  In addition the special properties above, Graffiti objects 
  So long as the five properties above are formatted correctly, the Graffiti server will accept <em>any</em> other JSON properties.
  <em>However</em>, by default the Graffiti client library filters ingoing and outgoing objects to adhere to the
  <a href="https://www.w3.org/TR/activitystreams-vocabulary">
    Activity Vocabulary
  </a> specification.
</p>

<p>
  This means that while you technically allowed to develop a new schema, most other apps won't "speak" the same language and your content won't interoperate.
  The Activity Vocabulary is flexible however, but it's best to extend the schema by inventing new properties rather than overwriting new ones.
</p>

<footer>
  <router-link to="/context">
    Context
  </router-link>
</footer>
