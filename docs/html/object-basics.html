<h1>
  Object Basics
</h1>

<p>
  Graffiti is essentially a shared database of JSON objects.
  You can put objects into the database that can represent things posts, likes, or profile information.
  Then you or other people can query the database for objects that are relevant to them.
</p>

<p>
  Graffiti is not any old database, it has certain properties that allow you to limit <em>who</em> can see your data and <em>where</em> they can see it.
  We'll get to that in the next sections on <RouterLink to="privacy">privacy</RouterLink> and <RouterLink to="context">context</RouterLink>
  but for now we're just going to introduce the basics of creating, viewing, and modifying data.
</p>

<p>
  To add data to the database you simply need to pass the JSON object you want to add to the global <code class="language-js">$graffitiUpdate</code> function.
  In the example below, clicking the button creates an object with <code class="language-js">type</code> "Boop".
</p>

<GraffitiPlayground path="booper" />

<p>
  Did you click the button and nothing happened? Well, we also need a way to <em>view</em> objects in the Graffiti database.
</p>

<p>
  To see objects that you or others have created you can use 
  <code class="language-js">GraffitiObjects</code>,
  a <a href="https://vuejs.org/guide/components/slots.html#renderless-components">renderless Vue component</a>.
  The component uses a <a href="https://vuejs.org/guide/components/slots.html#scoped-slots">scoped slot</a> to expose the variable <code class="language-js">objects</code>, which is an array
  of all the JSON objects matching certain filters.
</p>

<p>
  Below, we're mapping the <code class="language-js">objects</code> variable exposed by the <code class="language-js">GraffitiObjects</code> component to the variable <code class="language-js">boops</code> &mdash; remapping the variable helps with readability and it prevents name collisions if you are using nested <code class="language-js">GraffitiObjects</code> components.
  Then, we're filtering for objects that <em>you</em> have created and we use <a href="https://json-schema.org/">JSON schema</a> notation to filter for objects of type "Boop".
</p>

<GraffitiPlayground path="boop-viewer" />

<p>
  JSON Schema is very flexible and eventually we suggest that you check out it's <a href="https://json-schema.org/learn/getting-started-step-by-step.html">tutorial</a> but basically <code class="language-js">properties</code> describes the schema of certain properties <em>if those properties exist</em> and <code class="language-js">required</code> specifies which properties <em>must</em> exist.
  Additional properties outside of those specified may also exist in the object. This can be disabled by setting <code class="language-js">additionalProperties: false</code> but we suggest that you never use this option as it can prevent interoperability between applications with different but overlapping schemas.
</p>

<p>
  Note making a boop in the top component is immediately reflected in the bottom component. In fact, the change is reflected immediately on other devices and for other users which makes it possible to use Graffiti for things like instant messaging and real-time collaborative editing.
</p>

<h2>
  Mutation
</h2>

<p>
  You can modify or delete any object you put into the Graffiti database.
  To modify a Graffiti object, all you need to do is modify it locally and that change will be synced with the server and other users. In the example below we create a button that turns Boops into Bops, just by directly modifying an object's <code class="language-js">type</code> property.
</p>

<p>
  You can delete objects by calling <code class="language-js">delete</code> on an object's <code class="language-js">id</code> property, as also demonstrated in the example below.
  <code class="language-js">id</code> is a unique URI assigned to every object that we'll describe along with other special regulated properties at the end of this section.
</p>

<p>
  Note that you <em>cannot</em> change or delete other people's objects.
  In later sections we describe how you can implement things like <RouterLink to="/moderation">moderation</RouterLink> and <RouterLink to="ordered-lists">ordered lists</RouterLink> under these restrictions.
</p>

<GraffitiPlayground path="boopbop" />

Alternatively you can call the <code class="language-js">removeMine</code> function on an <code class="language-js">objects</code> array to remove all objects from that array that you created.
This is useful for clearing "reaction" objects such as "likes" or the "Wave" objects used in the <RouterLink to="/">introduction</RouterLink> demo.

<GraffitiPlayground path="remove-mine" />

<h2>
  Filtering and Sorting
</h2>

<p>
  As we saw in the last demo, you can filter objects using the keyword <code class="language-js">mine</code> and by passing in a JSON schema <code class="language-js">schema</code>.
  Alternatively, you can also pass in a <code class="language-js">filter</code> function, or a <code class="language-js">sort</code> function which are equivalent to the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter">prototypical Array functions</a>. For example:

  <GraffitiPlayground path="boop-viewer-filter" />
</p>

<p>
  Using <code class="language-js">filter</code> is more concise in this case, but it is less human-readable.
  We recommend using <code class="language-js">schema</code> as much as possible unless there is something that requires special programmatic filtering that is outside the scope of JSON schema.
</p>

<p>
  We also provide a more concise version of <code class="language-js">sort</code> via the function <code class="language-js">sortBy</code>.
  This function sorts the array by a particular property.
  For example, in later demos you will see <code class="language-js">:sortBy="-published"</code>
  which sorts objects by <code class="language-js">published</code>, a field that stores the time that objects are created.
  Adding the minus sign sorts objects in <em>reverse</em> order, putting the most recently created objects first.
  You can also sort by nested properties using dot notation, e.g. <code class="language-js">:sortBy="foo.bar"</code>.
</p>

<h2>
  Default Filtering
</h2>

<p>
  Graffiti objects are very flexible but there are certain properties that are enforced either because they have special server-side meanings or because they are convention.
</p>

<p>
  The following are special server-regulated fields:
</p>

<ul>
  <li>
    <code class="language-js">id</code>
    is a unique identifier associated with each object.
    As described above, deleting this required property deletes the whole object.
    It also acts as a "link" to the object, as we'll see in <RouterLink to="/context">§Context</RouterLink>.
  </li>
  <li>
    <code class="language-js">context</code>
    is a list of unique identifiers that specify "where" an object can be found.
    We explore this property in depth in <RouterLink to="/context">§Context</RouterLink>.
  </li>
  <li>
    <code class="language-js">actor</code>
    is a unique identified associated with each user and also attached to each object.
    This is important for both <RouterLink to="/context">context</RouterLink> and <RouterLink to="/privacy">privacy</RouterLink>
  </li>
  <li>
    <code class="language-js">bto</code>
    and
    <code class="language-js">bcc</code>
    optionally specify who is allowed to see an object, via an array of actor URIs.
    If either field is not included the object is public.,
    We explore these properties in depth in <RouterLink to="/privacy">§Privacy</RouterLink>.
  </li>
  <li>
    <code class="language-js">published</code>
    and
    <code class="language-js">updated</code>
    are required timestamps that specify when an object was created and when it was last updated.
  </li>
</ul>

<p>
<code class="language-js">id</code>, <code class="language-js">actor</code>, <code class="language-js">published</code>, and <code class="language-js">updated</code>  are assigned automatically when you call <code class="language-js">$graffitiUpdate</code>. <code class="language-js">context</code>, <code class="language-js">bto</code>, and <code class="language-js">bcc</code> must be assigned manually, although <code class="language-js">context</code> is given a default as specified in <RouterLink to="/context">§Context</RouterLink>.
</p>

<p>
  In addition the special properties above, it is <em>highly recommended</em> that the objects you create adhere to the
  <a href="https://www.w3.org/TR/activitystreams-vocabulary">
    Activity Vocabulary
  </a> specification.
  In fact, by default the client library will prevent you from creating or viewing objects that violate the specification to encourage interoperability.
</p>

<p>
  Adhering to the Activity Vocabulary means making sure that certain properties have certain formats. For example, the properties <code class="language-js">type</code>, <code class="language-js">content</code>, and <code class="language-js">name</code> must be strings and the property <code class="language-js">image</code> must be an image URL or a list of image URLs.
  The specification does not restrict you from defining <em>additional</em> properties.
  For example, you could create a property <code class="language-js">weight</code> that defines how heavy an object is &mdash; maybe this is useful for creating an online video game.
  Over time, we expect popular properties to become part of the <a href="https://en.wikipedia.org/wiki/Folksonomy">folksonomy</a>
</p>

<footer>
  <router-link to="/context">
    Context
  </router-link>
</footer>
